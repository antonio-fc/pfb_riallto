import npu
import numpy as np
from npu.build.appbuilder import AppBuilder
from npu.runtime import AppRunner
import pylab as plt
import scipy

from npu_stuff import buildApp, runApp

def db(x):
    """ Convert linear value to dB value """
    return 10*np.log10(x, out=np.zeros_like(x, dtype=np.float32), where=(x!=0))

def generate_win_coeffs(M, P, window_fn="hamming"):
    win_coeffs = scipy.signal.get_window(window_fn, M*P)
    sinc       = scipy.signal.firwin(M * P, cutoff=1.0/P, window="rectangular")
    win_coeffs *= sinc
    return win_coeffs

def createKernel(kernel_name):
    kernel_path = f"./kernels/{kernel_name}.c"
    with open(kernel_path, 'r') as file:
        data = file.read()
    get_ipython().run_cell_magic('kernel', '', data)

def generateKernels(W, M, P):
    # Passtrough kernel
    createKernel("passthrough2")
    dt = np.float32
    passthrough.ports[0].array = np.ndarray([1, M*P], dtype=dt)
    passthrough.ports[1].array = np.ndarray([1, M*P], dtype=dt)
    passthrough.ports[2].array = np.ndarray([1, M*P], dtype=dt)

    return [passthrough]

if __name__ == "__main__":
    M     = 2          # Number of taps
    P     = 1024       # Number of 'branches', also fft length
    W     = 1024       # Number of windows of length M*P in input time stream
    n_int = 10          # Number of time integrations on output data
    dt=np.float32

    # Creating the app
    kernels = generateKernels(W, M, P)
    app = buildApp(kernels, M, P, dt)

    # Generating input data
    noise = np.random.normal(loc=0.5, scale=0.1, size=M*P).astype(dt)
    samples = np.arange(M*P)
    freq    = 1
    amp     = 1
    cw_signal = (amp * np.sin(samples * freq))
    data = noise + cw_signal
    plt.plot(data)
    plt.savefig('./plots/input.png')
    plt.clf()

    # Generate window coefficients
    win_coeffs = generate_win_coeffs(M, P, "hamming")
    pg = np.sum(np.abs(win_coeffs)**2)
    win_coeffs /= pg**.5 # Normalize for processing gain
    win_coeffs = win_coeffs.astype(dt)
    plt.plot(win_coeffs)
    plt.savefig('./plots/coeff_input.png')
    plt.clf()

    # Run app
    output_data = runApp(app, M, P, data, win_coeffs, dt)

    # Checking results
    print(f"Are the arrays are equal?: {np.array_equal(data, output_data)}")

    gg = np.zeros(shape=(1, M*P), dtype=dt)
    gg[:] = output_data
    gg = gg[0]
    # print(type(gg))
    # print(gg.shape)
    # print(gg.dtype)
    # print(gg)
    plt.plot(gg)
    plt.savefig('./plots/output.png')

    # Clean-up
    del app
    
    