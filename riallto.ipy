import npu
import numpy as np
import scipy
from npu.utils import OpenCVImageReader, image_plot
from PIL import Image
from IPython import get_ipython
import pylab as plt
import seaborn as sns

from func import pfb_spectrometer
from npu_stuff import buildApp
    
# Making the passthrough kernel
def createKernel(kernel_name):
    kernel_path = f"./kernels/{kernel_name}.c"
    with open(kernel_path, 'r') as file:
        data = file.read()
    get_ipython().run_cell_magic('kernel', '', data)

def generateKernels():
    # Passtrough kernel
    createKernel("passthrough2")
    dt = np.float32
    passthrough.ports[0].array = np.ndarray([1, M*P], dtype=dt) # uint16_t as placeholder of same size
    passthrough.ports[1].array = np.ndarray([1, M*P], dtype=dt)
    passthrough.ports[2].array = np.ndarray([1, M*P], dtype=dt)

    return [passthrough]


######################################### MAIN STUFF #################################################
def db(x):
    """ Convert linear value to dB value """
    return 10*np.log10(x, out=np.zeros_like(x, dtype=np.float32), where=(x!=0))

def generate_win_coeffs(M, P, window_fn="hamming"):
    win_coeffs = scipy.signal.get_window(window_fn, M*P)
    sinc       = scipy.signal.firwin(M * P, cutoff=1.0/P, window="rectangular")
    win_coeffs *= sinc
    return win_coeffs

if __name__ == "__main__":
    sns.set_style("white")
    
    M     = 2          # Number of taps
    P     = 1024       # Number of 'branches', also fft length
    W     = 1024       # Number of windows of length M*P in input time stream
    n_int = 10          # Number of time integrations on output data
    dt = np.float32

    # Kernels need to be created in this file (ipython file)
    kernels = generateKernels()

    # Generate a test data steam
    samples = np.arange(M*P*W)
    noise   = np.random.normal(loc=0.5, scale=0.1, size=M*P*W)
    freq    = 1
    amp     = 1
    cw_signal = (amp * np.sin(samples * freq))
    data = (noise + cw_signal).astype(dt)

    # Generate window coefficients
    win_coeffs = generate_win_coeffs(M, P, "hamming")
    pg = np.sum(np.abs(win_coeffs)**2)
    win_coeffs /= pg**.5 # Normalize for processing gain
    win_coeffs = win_coeffs.astype(dt)

    # Building app
    app = buildApp(M, P, W, kernels)
    
    # # Image 1
    X_psd = pfb_spectrometer(data, n_taps=M, n_chan=P, n_win=W, n_int=16, win_coeffs=win_coeffs, app=app)
    # plt.imshow(db(X_psd), cmap='viridis', aspect='auto')
    # plt.colorbar()
    # plt.xlabel("Channel")
    # plt.ylabel("Time")
    # plt.savefig('./plots/plot1.png')

    # # Image 2
    X_psd2 = pfb_spectrometer(data, n_taps=M, n_chan=P, n_win=W, n_int=16, win_coeffs=win_coeffs, app=app)
    # plt.plot(db(X_psd[0]), c='#cccccc', label='short integration')
    # plt.plot(db(X_psd2[1]), c='#cc0000', label='long integration')
    # plt.xlim(0, P/2)
    # plt.xlabel("Channel")
    # plt.ylabel("Power [dB]")
    # plt.legend()
    # plt.savefig('./plots/plot2.png')

    del app