import npu
import numpy as np
import pylab as plt
import scipy
import time

from npu_stuff import buildApp
from func import pfb_spectrometer

def db(x):
    """ Convert linear value to dB value """
    return 10*np.log10(x, out=np.zeros_like(x, dtype=np.float32), where=(x!=0))

def generate_win_coeffs(M, P, window_fn="hamming"):
    win_coeffs = scipy.signal.get_window(window_fn, M*P)
    sinc       = scipy.signal.firwin(M * P, cutoff=1.0/P, window="rectangular")
    win_coeffs *= sinc
    return win_coeffs

def createKernel(kernel_name):
    kernel_path = f"./kernels/{kernel_name}.c"
    with open(kernel_path, 'r') as file:
        data = file.read()
    get_ipython().run_cell_magic('kernel', '', data)

def generateKernels(W, M, P):
    # Passtrough kernel
    createKernel("passthrough2")
    dt = np.float32
    passthrough.ports[0].array = np.ndarray([1, M*P], dtype=dt)
    passthrough.ports[1].array = np.ndarray([1, M*P], dtype=dt)
    passthrough.ports[2].array = np.ndarray([1, M*P], dtype=dt)

    return [passthrough]

if __name__ == "__main__":
    M     = 2          # Number of taps
    P     = 1024       # Number of 'branches', also fft length
    W     = 1024       # Number of windows of length M*P in input time stream
    n_int1 = 16          # Number of time integrations on output data
    n_int2 = 1024
    dt=np.float32

    # Creating the app
    kernels = generateKernels(W, M, P)
    app = buildApp(kernels, M, P, dt)

    # Generating input data
    noise = np.random.normal(loc=0.5, scale=0.1, size=M*P*W).astype(dt)
    samples = np.arange(M*P*W)
    freq    = 1
    amp     = 1
    cw_signal = (amp * np.sin(samples * freq))
    data = noise + cw_signal
    plt.plot(data)
    plt.savefig('./plots/input.png')
    plt.clf()

    # Generate window coefficients
    win_coeffs = generate_win_coeffs(M, P, "hamming")
    pg = np.sum(np.abs(win_coeffs)**2)
    win_coeffs /= pg**.5 # Normalize for processing gain
    win_coeffs = win_coeffs.astype(dt)
    plt.plot(win_coeffs)
    plt.savefig('./plots/coeff_input.png')
    plt.clf()

    # Run app
    X_psd = pfb_spectrometer(app, data, win_coeffs, M, P, W, n_int1, dt)
    X_psd2 = pfb_spectrometer(app, data, win_coeffs, M, P, W, n_int2, dt)

    # Checking results
    plt.imshow(db(X_psd), cmap='viridis', aspect='auto')
    plt.colorbar()
    plt.xlabel("Channel")
    plt.ylabel("Time")
    plt.savefig('./plots/plot1.png')
    plt.clf()

    plt.plot(db(X_psd[0]), c='#cccccc', label='short integration')
    plt.plot(db(X_psd2[1]), c='#cc0000', label='long integration')
    plt.xlim(0, P/2)
    plt.xlabel("Channel")
    plt.ylabel("Power [dB]")
    plt.legend()
    plt.savefig('./plots/plot2.png')

    # Clean-up
    del app
    
    